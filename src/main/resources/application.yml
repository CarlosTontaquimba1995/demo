server:
  port: 8081
  
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info,prometheus,circuitbreakers,ratelimiters
  metrics:
    enable:
      kafka: true
    distribution:
      percentiles-histogram:
        http.server.requests: true
    web:
      server:
        request:
          autotime:
            enabled: true
  health:
    kafka:
      enabled: true
    diskspace:
      enabled: true
    db:
      enabled: true
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  endpoint:
    health:
      show-details: always

# Configuración de Logs
logging:
  level:
    root: INFO
    org.springframework.web: INFO
    factura.flow: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    org.springframework.kafka: INFO
    org.apache.kafka: WARN
    org.springframework.retry: DEBUG

spring:
  application:
    name: notarial-orchestrator
  
  # Habilita Hilos Virtuales
  threads:
    virtual:
      enabled: true

  # Configuración de Base de Datos
  datasource:
    url: jdbc:sqlserver://10.1.27.16:1435;database=NOTARIAL_JAVA;instanceName=DESA07;encrypt=false
    username: DESA_PESNOT24
    password: dEpesNOT2024*
    driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.SQLServer2016Dialect
        format_sql: true
        hbm2ddl.auto: none
        physical_naming_strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
        implicit_naming_strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
        lob:
          non_contextual_creation: true
        jakarta.persistence.schema-generation.database.action: none
        hibernate.connection.default_schema: dbo

  # Configuración de Kafka
  kafka:
    # Configuración de seguridad
    security:
      protocol: ${KAFKA_SECURITY_PROTOCOL:SSL}
      ssl:
        trust-store-location: ${KAFKA_SSL_TRUSTSTORE_LOCATION:classpath:kafka.client.truststore.jks}
        trust-store-password: ${KAFKA_SSL_TRUSTSTORE_PASSWORD:changeit}
        key-store-password: ${KAFKA_SSL_KEYSTORE_PASSWORD:changeit}
        key-password: ${KAFKA_SSL_KEY_PASSWORD:changeit}
    
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    
    # Configuración del consumidor
    consumer:
      group-id: ${KAFKA_GROUP_ID:factura-group-${random.uuid}}  # Se genera un nuevo ID de grupo en cada inicio
      client-id: ${spring.application.name}-${random.uuid}
      auto-offset-reset: latest  # Solo consume mensajes nuevos
      enable-auto-commit: false
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
        spring.json.use.type.headers: false
        max.poll.interval.ms: 300000  # 5 minutos
        session.timeout.ms: 45000     # 45 segundos
        heartbeat.interval.ms: 15000   # 15 segundos
        max.poll.records: 500         # Número de registros por poll
        fetch.min.bytes: 1048576      # 1MB
        fetch.max.wait.ms: 500
        max.partition.fetch.bytes: 1048576  # 1MB
        connections.max.idle.ms: 540000  # 9 minutos
        metadata.max.age.ms: 300000     # 5 minutos
        reconnect.backoff.ms: 50
        retry.backoff.ms: 100
        
    # Configuración del productor
    producer:
      acks: all
      # Configuración de Resilience4j
      properties:
        resilience4j.circuitbreaker.configs.default.slidingWindowSize: 20
        resilience4j.circuitbreaker.configs.default.permittedNumberOfCallsInHalfOpenState: 3
        resilience4j.circuitbreaker.configs.default.slidingWindowType: COUNT_BASED
        resilience4j.circuitbreaker.configs.default.minimumNumberOfCalls: 5
        resilience4j.circuitbreaker.configs.default.waitDurationInOpenState: 10s
        resilience4j.circuitbreaker.configs.default.failureRateThreshold: 50
    # Configuración de consumidores específicos (si es necesario)
    # Se eliminó la configuración duplicada que forzaba a consumir desde el principio

# Configuración de la Aplicación
app:
  kafka:
      processing: factura.processing
  security:
    oauth2:
      token:
        url: https://sso-desa.funcionjudicial.gob.ec/realms/notarial/protocol/openid-connect/token
        client-id: cj-web-app
        username: evaluaciones-funcion-judicial
        password: Pesnot2024.
        refresh-offset-seconds: 60
        refresh-check-interval-ms: 300000
  external-api:
    base-url: https://desa-api-pesnot.funcionjudicial.gob.ec/SRI-SERVICE/api/sri/master/process-invoice
    timeout-ms: 5000

# Resilience4j Configuration
# Configuración de Resilience4j
  ratelimiter:
    configs:
      default:
        limitForPeriod: 100
        limitRefreshPeriod: 1s
        timeoutDuration: 1s
  retry:
    configs:
      default:
        maxAttempts: 3
        waitDuration: 100ms
  bulkhead:
    configs:
      default:
        maxConcurrentCalls: 100
        maxWaitDuration: 0

# Configuración de Actuator para monitoreo